<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <title>Ciencia abierta: publicando informes abiertos</title>
    
    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/extra.css">
    <link rel="stylesheet" href="css/theme/white.css">
    
    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">
    
    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
	<section><h1>Ciencia abierta</h1></section>
	<section><h1>Como las croquetas: todo vale</h1>
	  <h2 class='fragment'>Resultados negativos, datos, presentaciones, pósters</h2>
	</section>

	<section><h1>Bitácora abierta</h1>
	  <h2>Mantener un diario de los resultados y fracasos</h2>
	</section>

	<section><h1>Ejercicio</h1>
	  <ul><li>Contar en una frase un proyecto</li>
	    <li>Organizarse en equipos</li>
	    <li>Crear un proyecto y añadir al resto del equipo</li>
	  </ul>
	</section>

	<!-- Organizando la bitácora y el trabajo -->
	<section>
	  <section><h1>Haciendo la bitácora</h1>
	    <h2>Usando fichero <code>ChangeLog</code> + editor</h2>

	    <aside class='notes'>Estés o no trabajando con algún lenguaje de programación o proyecto, es importante <a href='http://keepachangelog.com/en/1.0.0/'>manener un log de cambios o bitácora</a>. El que esté asociado a un sistema de control de fuentes permite que asocies los valores de ficheros de configuración a el punto de la historia. También se puede usar simplemente el commit, aunque hay que ser disciplinado al respecto y sobre todo hacer commits muy atómicos, con cambios pequeños.</aside>
	  </section>

	  <section><h1>Organización del trabajo</h1>
	    <h2>Hace falta repartir las tareas desde el principio</h2>
	  </section>

	  <section><h1>Uso de <em>Milestones</em> e <em>issues</em></h1>
	    <h2 class='fragment'><em>Milestones</em>: hitos con fecha "Congreso ZYX"</h2>
	    <h2 class='fragment'><em>Issues</em>: tareas siempre dentro de un hito</h2>
	  </section>

	  <section><h1>El trabajo se organiza en tareas</h1>
	    <h2 class='fragment'>Los commits siempre mencionan una tarea</h2>
	    <pre class='fragment'><code>git commit -am "Revisa abstract refs #2"</code></pre>
	    <aside class='notes>En principio, un issue lo puede asignar quien quiera. También se lo puede uno auto-asignar.</aside>
	  </section>

	  <section><h1>Los issues se deben asignar a alguien</h1>
	    <h2 class='fragment'>O mencionarse en el cuerpo del mismo usando @</h2>
	  </section>

	  <section><h1>Los issues se pueden etiquetar</h1>
	    <h2 class='fragment'>Mejoras, errores, revisión...</h2>
	  </section>

	  <section><h1>Issues (y commits) usan markdown</h1>
	    <h2 class='fragment'>Usarlo para enlaces o nombres de ficheros, por ejemplo</h2>
	  </section>

	  <section><h1>Usa Markdown con tu editor favorito</h1>
	    <h2 class='fragment'>O con R Studio</h2>
	    <aside class='notes'>Igual es un buen momento para instalarse R Studio, que es una herramienta genial para trabajar con R, LaTeX, markdown y un montón de cosas más</aside>
	  </section>
	  
	  <section><h1>Issues se cierran desde un commit</h1>
	    <h2>Tarea terminada:</h2>
	    <pre><code>git commit -am "Revisada intro closes #3"</code>
	    </pre>
	    <aside class='notes'>Closes, o fixes, o solves, porque se refiere a "bugs"</aside>
	  </section>
	  
	  <section><h1>Ejercicio</h1>
	    <h2>Comenzar con la organización del proyecto usando GitHub, bitácora</h2>
	    <h3 class='fragment'>Obtener datos y añadirlos al repo, por ejemplo, describir el proyecto en GitHub...</h3>
	  </section>
	</section>

	<!-- Gestionando colaboración -->
	<section>
	  <section><h1>Ciencia abierta tiene que ser abierta</h1>
	    <aside class='notes'>Parece una tautología, pero hay que estar dispuesto a aceptar colaboraciones</aside>
	  </section>

	  <section><h1>Formas de buscar colaboración</h1>
	    <ol><li>Issues <em>para principiantes</em></li>
	      <li>Fichero <code>CONTRIBUTING.md</code></li>
	      <li>Conexión con redes sociales/grupo Telegram</li>
	    </ol>
	  </section>

	  <section><h1><em>Pull request</em>: petición de fusión</h1>
	    <h2>Para personas que no tengan permiso de escritura en el repositorio</h2>
	    <aside class='notes'>Los pull requests equivalen a
	    fusionar dos versiones de un repositorio, y sirven sobre
	    todo para colaboración ocasional. Se trata de una petición
	    (request) de un pull (fusión), es decir, alguien te está
	    pidiendo que tú incorpores a tu repositorio los cambios
	      que ha hecho</aside>
	  </section>
	  
	  <section><h1>Gestionando <em>pull requests</em></h1>
	    <h2>Mejor tener una <a href='https://help.github.com/articles/creating-a-pull-request-template-for-your-repository/'>plantilla</a></h2>
	    <h2>Contestar siempre</h2>
	    <h2>Revisar y sugerir cambios</h2>
	    <aside class='notes'>Los PR en GitHub son todo un sistema de revisión e inclusión de código. Permiten comentarios en líneas específicas, comentarios generales, aceptar o solicitar cambios, e incluso pasar tests a los cambios. Bien gestionados, son un gran mecanismo para abrir nuestra ciencia.</aside>
	  </section>

	  <section><h1>Ejercicio</h1>
	    <ol><li>Preparar los proyectos para pull requests</li>
	      <li>Hacer un <em>pull request</em> a otro proyecto.</li>
	      <li>Revisar el <em>pull request</em> hecho</li>
	    </ol>
	  </section>
	</section>

	<section>
	  <section><h1>Comencemos con R Studio</h1>
	    <h1>Para R, LaTeX, R Markdown, knitr</h1>
	    <aside class='notes'>Yo uso emacs y me va estupendamente. RStudio sólo te permite hacer cosas usando un interfaz gráfico, usando por debajo comandos como LaTeX y demás. Para instalarlo en Linux se hace desde los repos, en Windows o Mac no debería ser tan difícil. Seguir instrucciones.</aside>
	  </section>

	  <section><h1>Breve introducción a R</h1>
	    <h2>R es un lenguaje especializado en proceso de datos</h2>
	    <aside class='notes'>Aquí aprenderemos lo suficiente para poder introducirlo en un documento y generar algún gráfico.</aside>
	  </section>

	  <section><h1>Leyendo datos</h1>
	    <pre><code># Visitas extraídos de la Wikipedia española via API
data.2016 <- read.table("data/Cataluña-2016.dat")
data.2017 <- read.table("data/Cataluña-2017.dat")
	     </code></pre>
	    <h2 class='fragment'><em>Run</em> o copiar en consola</h2>
	  </section>

	  
	  <section><h1>Escribiendo la historia</h1>
	    <h2>Datos → <code>.Rdata</code></h2>
	    <h2>Historia → <code>.Rhistory</code></h2>
	    <code class='fragment'><pre>git add .R*</pre></code>
	    <aside class='notes'>De esta forma puedes tener el mismo entorno trabajes donde trabajes y recordar las órdenes que has ejecutado, incluso aunque no las hayas registrado en un programa</aside></section>
	  <section><h1>Procesa datos → Fichero bajo git</h1>
	    <pre><code>git add procesadatos.R</code></pre>
	  </section>
	  <section><h1>Visualizando los datos</h1>
	    <h2 class='fragment'>Ventana <em>Environment</em></h2>
	    <pre class='fragment'><code>plot(rownames(data.2016),data.2016$V1)</code>
	    </pre>
	  </section>

	  <section><h1>Ejercicio</h1>
	    <h2>Tomar el conjunto de datos y crear un fichero para cargarlo y visualizarlo.</h2>
	    <aside class='notes'>Cumpliendo las provisiones del cuaderno de bitácora abierto y usando GitHub para organizarse. Se pueden hacer los scripts en colaboración o bien organizar el trabajo para diferentes visualizaciones o proceso (si ya se conoce R un poco).</aside>
	  </section>
	</section>

	<!-- Presentando FigShare -->
	<section>
	  <section><h1>FigShare permite publicar (casi) todo</h1>
	    <h2 class='fragment'>Figuras + datos + presentaciones + código</h2>
	    <h3 class='fragment'>Proporciona DOI bajo demanda</h3>
	    <aside class='notes'>También papers, claro está. El principal problema es que no esa indexada por Google Scholar</aside>
	  </section>

	  <section><h1>Conexión con Altmetrics</h1>
	    <h2>Evaluación del trabajo más allá de las citas</h2>
	    <h3>Lecturas, descargas...</h3>
	  </section>

	  <section><h1>Publicación de los datos de visitas</h1>
	    <h1>En <a href='https://figshare.com/articles/Visitas_a_la_wikipedia_p_gina_Catalu_a_septiembre-octubre_2016_y_2017/5572471'>este enlace</a></h1>
	    <h2>Licencia CC-BY</h2>
	  </section>

	  <section><h1>Ejercicio</h1>
	    <h2>Darse de alta en FigShare y subir gráfica y datos usados anteriormente.</h2>
	  </section>
	</section>

	<!-- Algún procesamiento de datos -->
	<section>
	  <section><h1>Usando <em>data frames</em></h1>
	    <h2>Datos organizados el filas y columnas</h2>
	    <pre><code>data <- data.frame(visitas.2016=data.2016$V1,
			       visitas.2017=data.2017$V1,
			       ratio=data.2017/data.2016) </code></pre>

			       <aside class='notes'>Si se ejecuta en RStudio, la variable se puede visualizar directamente en el panel de Environment</aside>
	  </section>

	  <section><h1>Algo de estadística</h1>
	    <pre><code>print(mean(data.2016$V1))
print(mean(data$visitas.2017))</code></pre>

	    <aside class='notes'>$ se usa para seleccionar columnas de un data frame. En el primer caso también se trataba de un data frame y la variable V1 se le asignaba automáticamente. <code>print</code> imprime, y hay toda una cantidad de tests estadísticos que se pueden hacer.</aside>

	    <pre
	    class='fragment'><code>wilcox.test(data.2016$V1,data.2017$V1)</pre></code>

	    <aside class='notes'>El test de Wilcoxon asegura si dos
	    variables estadísticas son iguales o no. El coeficiente p
	      debe ser menor que 0.05 para que sea así. </aside>

	  </section>
	  
	  <section><h1>Más estadística</h1>
	    <pre><code>data.test <- wilcox.test(data$visitas.2017,data$visitas.2016)
if (data.test$p.value < 0.05) {
    print("Medias diferentes")
} </pre></code>
	    
	    <aside class='notes'>R puede hacer automáticamente una
	      serie de nilTODO: ests estadísticos. El resultado de los mismos es
	      también una variable (una lista en este caso), que contiene
	      en sus diferentes apartados los resultados del test.   </aside>
	  </section>
	  
	  <section><h1>Ejercicio</h1>
	    <h2>Hacer diferentes tests estadísticos sobre los datos que se han elegido, incluyéndolos en el código</h2>
	    
	    <aside class='notes'>Si no se está familiarizado con la
	      estadística, se pueden hacer simplemente máximos y
	      mínimos. Todos los tests estadísticos deben estar bajo
	      control de fuentes, y en general es conveniente que estén
	      todos uno detrás de otro en el script</aside>
	  </section>
	  </section>
	  
	  <!-- Open Science Framework -->
	  <section>
	    <section><h1>Open Science Framework</h1>
	      <h1><a
		href='https://osf.io'><code>osf.io</code></a></h1>
	      <h2>Alta con cuenta de ORCID</h2>
	    </section>

	    <section><h1>Ejercicio</h1>
	      <h2>Alta en OSF, si es necesario dándose se alta
		previamente en ORCID</h2>
	    </section>

	    <section><h1>Almacenando datos</h1>
	      <h2>OSF tiene almacenamiento propio y permite almacenar
		ficheros muy grandes</h2>
	      <h2 class='fragment'>También conectar otros sitios, como
		GitHub</h2>
	    </section>

	    <section><h1>Gestionando proyectos con OSF</h1>
	      <h2>Los proyectos tienen Wiki y se pueden añadir
		diferentes personas</h2>
	      <h2>OSF para proyectos, FigShare para ficheros
		puntuales</h2>

	      <aside class='notes'>Se pueden alcanzar una buena
	    cantidad de citas en este tipo de publicaciones. Por
	    ejemplo <a
	    href='http://www.citeulike.org/group/19226/article/13701202'>esta
		descripción de una biblioteca con 48 citas</a></aside>
	    </section>

	    <section><h1>Ejercicio</h1>
	      <h2>Crear un proyecto para cada grupo, añadiendo a los
		miembros, y conectarlo a la cuenta de GitHub</h2>
	    </section>

	    <section><h1>Buenas prácticas</h1>
	      <h2 class='fragment'>Mantener todos los ficheros
		juntos</h2>
	      <h2 class='fragment'>Nombres comunes para directorios:
		<code>data</code>, <code>script</code>,
		<code>report</code> o <code>paper</code>
	      </h2>
	      <h3 class='fragment'>Comentarios en código o datos</h3>
	      <aside class='notes'>GitHub, además, permite buscar
	      fácilmente entre tus ficheros, con lo que es una ventaja
	      adicional. Todos los datos deben estar en GitHub, con
	      publicación adicional en otros lugares como FigShare u
		Open Source Framework</aside>
	    </section>

	    <section><h1>Publicando todo</h1>
	      <h2>Trabajo rechazado</h2>
	      <h2>Información adicional solicitada por revisor</h2>
	      <h2>Pruebas para establecer parámetros</h2>
	      <h3>Ponencia sin trabajo publicado</h3>
	      <aside class='notes'>También pruebas de concepto para
	    poner a punto el procesamiento de datos, por ejemplo,
	    gráficos iniciales que no se van a publicar en la versión
	    final... FigShare y OSF permiten publicación rápida,
		inmediata y citable</aside>
	    </section>
	  </section>

	  <!-- Incluyendo gráficos -->
	  <section>
	    <section><h1>Ningún buen trabajo sin gráficos</h1>
	      <h2>R tiene gráficos básicos (<code>plot</code>), pero
		mejor <code>ggplot2</code></h2>
	    </section>

	    <section><h1><code>ggplot2</code> → Gramática gráfica</h1>
	      <h2>Permite <em>construir</em> gráficos elemento a
		elemento</h2>
	      <h3><code>ggplot()</code> + gráficos + elementos_adicionales</h3>
	      <aside class='notes'>Así se pueden hacer varias
	      versiones de un gráfico, añadir o quitar elementos o
		incluso modificarlos</aside>
	    </section>

	    <section><h1>La <em>estética de los gráficos</em></h1>
	      <h2>Los gráficos incluyen <code>aes</code>thetics →
		elementos del gráfico</h2>
	    </section>

	    <section><h1>Instalar la biblioteca</h1>
	      <pre><code>package.install("ggplot2")</code></pre>

	      <h2 class='fragment'>Usar la biblioteca</h2>
	      <pre><code># Al principio del script
library(ggplot2)</code></pre>

	    </section>

	    <section><h1>Gráfico de visitas por año</h1>
	      <h2>Añadimos columna con fechas</h2>
	      <pre><code>dias.sept <- paste0(1:30,c("/09"))
dias.oct <- paste0(1:31,c("/10"))
data$dias <- as.Date(c(dias.sept, dias.oct, "01/11"),format="%d/%m")</code></pre>	      
	      <aside class='notes'>Es esencial que estén en un formato
		fecha para que se ordene correctamente</aside>
	    </section>

	    <section><h1>Y creamos el gráfico</h1>
	      <pre><code>grafico <- ggplot()+ geom_line(data=data,aes(x=dias,y=visitas.2015,color="2015",group=1))
grafico <- grafico + geom_line(data=data,aes(x=dias,y=visitas.2016,color="2016",group=1)) + geom_line(data=data,aes(x=dias,y=visitas.2017,color="2017",group=1))
grafico <- grafico + theme(axis.text.x = element_text(angle = 90, hjust = 1))
grafico</code></pre>
	      <aside class='notes'>Trabajar con una variable nos
	      permite ser más flexibles y también legibles. Esa
		variable la podemos pasar por una función, por ejemplo</aside>
	    </section>

	    <section><h1>Bonito resultado</h1>
	      <pre><code>ggsave("visitas-wikipedia-CAT.png")</code></pre>
	      <h2>Y reproducible</h2>
	      <aside class='notes'>El aspecto de los gráficos de
	      ggplot es infinitamente mejor que el de los gráficos de
	      Excel y universalmente mejor que los nefastos gráficos
	      capturados de una pantalla de Excel (que tanto me he
		encontrado por ahí).</aside>
	    </section>
	    
	    <section data-background='../img/visitas-wikipedia-CAT.png'
		   alt='Visitas wikipedia'>
	    </section>

	    <section><h1>Ejercicio</h1>
	      <h2>Generar uno o varios gráficos para el conjunto de
		datos usado</h2>
	      <aside class='notes'>Como se ha venido haciendo hasta
	      ahora, usar las prácticas de asignar tareas, guardar
	      todo en el fichero de control de fuentes, y
	      eventualmente subir el gráfico a FigShare o dejarlo
		dentro del proyecto de OSF si ya está
		conectado</aside>
	    </section>
	    </section>

	    <!-- Ahora vamos al RMarkdown -->
	    <section>
	      <section><h1>RMarkdown integra R y Markdown</h1>
		<h2><em>Programación literaria</em></h2>
		<h3>Integra el contenido con el procesamiento
		  necesario para generar imágenes.</h3>
	      </section>

	      <section><h1>Abrimos un proyecto RMarkdown</h1>
		<h2>(Cargando antes el proyecto en RStudio)</h2>
		<img src='../img/rmarkdown.png' alt='creando documento
		     RMarkdown'>
	      </section>
	      <section><h1>Plantilla inicial</h1>
		<pre><code>---
title: "Visitas a la página de Cataluña en la Wikipedia"
author: "JJ Merelo"
date: "5 de noviembre de 2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown</code></pre>
		<aside class='notes'>Se genera automáticamente con un
		  contenido que nosotros podemos modificar. Las línes
		iniciales son metadatos, rellenados en parte con
		nuestra contestación al pop up. Debajo de las segundas
		  --- comienza el texto, con código R entre ```
		</aside>
	      </section>

	      <section><h1>Guardar con extensión
		<code>.Rmd</code></h1>
		<h2><em>Knit</em> genera el fichero con el formato que
		  se desee</h2>
	      </section>

	      <section><h1>Carga de ficheros y procesamiento
		inicial</h1>
		<pre><code>```{r setup, include=FALSE}
library(ggplot2)
data.2015 <- read.table("../data/Cataluña-2015.dat") # ...

dias.sept <- paste0(1:30,c("/09"))
dias.oct <- paste0(1:31,c("/10"))
data$dias <- as.Date(c(dias.sept, dias.oct, "01/11"),format="%d/%m")
```</code></pre>
		<aside class='notes'>Es la parte inicial del script,
		  entre tres comillas. Tras las llaves, se pone
		  <code>r</code> y se le asigna un nombre al
		  <em>chunk</em>. El resto son órdenes específicas del
		  chunk que especifican cosas como si se deben incluir
		  los warnings o no, si se presenta en el trabajo la
		  orden en sí o en este caso <a
		    href='http://kbroman.org/knitr_knutshell/pages/Rmarkdown.html'><code>include=false</code></a>
		  para que no se presenten ni el código ni el
		  resultado</aside>
	      </section>

	      <section><h1>Ejecutar código de prueba en la
		consola</h1>
		<h2>Usando "Run" o la flechita el la esquina del
		  chunk</h2>
		<aside class='notes'>Permite probar poco a poco lo que
		se va haciendo, incluso probar cosas en la consola
		  antes de escribirlas.</aside>
	      </section>

	      <section><h1>Ejercicio</h1>
		<h2>Integrar el script de procesamiento de datos en un
		fichero RMarkdown y escribir una pequeña introducción
		  al mismo.</h2>
	      </section>

	      <section><h1>Una imagen vale mil palabras</h1>
		<pre><code>```{r grafico, echo=FALSE}
grafico <- ggplot()+ geom_line(data=data,aes(x=dias,y=visitas.2015,color="2015",group=1))
grafico <- grafico + geom_line(data=data,aes(x=dias,y=visitas.2016,color="2016",group=1)) + geom_line(data=data,aes(x=dias,y=visitas.2017,color="2017",group=1))
grafico <- grafico + theme(axis.text.x = element_text(angle = 90, hjust = 1))
grafico
```</code></pre>
	      <aside class='notes'>echo=FALSE hace que no aparezca la
		orden en pantalla, pero sí el resultado. El poner
		"grafico", el nombre de la variable, al final del
		chunk es el que hace que aparezca</aside>
	    </section>

	    <section><h1>Buenas prácticas</h1>

	      <h2>Estructurar  texto + gráficos + órdenes</h2>
	      <img src='../img/texto.png' alt='organización del texto'>

	    </section>

	    <section><h1>Ejercicio</h1>
	      <h2>Escribir un borrador que incluya gráficos y
		explicación de los mismos</h2>
	    </section>

	    <section><h1>Publicación en RPubs</h1>
	      <img src='../img/rpubs.png' alt='organización del texto'>
	      <h2>Registro previo en <a
		href='https://rpubs.com'><code>rpubs.com</code></a></h2>
	    </section>

	    <section><h1>Uso para borradores e informes breves</h1>
	      <h2>Sin DOI, sin Google Scholar...</h2>
	    </section>

	    <section><h1>Ejercicios</h1>
	      <h2>Publicar en RPubs un informe breve con análisis de
		datos + gráficos</h2>
	    </section>
	    
	    </section>
      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>
    
    <script>
      // More info about config & dependencies:
      // - https://github.com/hakimel/reveal.js#configuration
      // - https://github.com/hakimel/reveal.js#dependencies
      Reveal.initialize({
      // Display a presentation progress bar
      progress: true,
      
      // Display the page number of the current slide
      slideNumber: true,
      
      // Push each slide change to the browser history
      history: true,
      
      // Enable keyboard shortcuts for navigation
      keyboard: true,
      width: "90%",
      dependencies: [
      { src: 'plugin/markdown/marked.js' },
      { src: 'plugin/markdown/markdown.js' },
      { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
      ]
      });
    </script>
  </body>
</html>
